//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : RegisterOps.cpp
//  @ Date : 2010-3-22
//  @ Author : 
//
//
#pragma   warning(   disable   :   4786   )  
#include "SysGlobal.h"
#include "libxml/XmlTree.h"
#include "RegisterOps.h"
#include <comutil.h>
#include <tchar.h>
#include "stringEx.h"
#include "CSector.h"
#include "FileOps.h"
//#include"stdafx.h"
#include<atlbase.h>
#include<atlconv.h>
#include"iphlpapi.h"
#pragma comment(lib,"Iphlpapi.lib")
int getNetworkCardMac(string pCardName, string & pMacAddress)
{
    PIP_ADAPTER_INFO pAdapterInfo;
    PIP_ADAPTER_INFO pAdapter=NULL;
    DWORD dwRetVal=0;
    pAdapterInfo=(IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));
    ULONG ulOutBufLen=sizeof(IP_ADAPTER_INFO);
    if(GetAdaptersInfo(pAdapterInfo,&ulOutBufLen)!=ERROR_SUCCESS)
    {
        free(pAdapterInfo);
        pAdapterInfo=(IP_ADAPTER_INFO*)malloc(ulOutBufLen);
    }
    if((dwRetVal=GetAdaptersInfo(pAdapterInfo,&ulOutBufLen))==NO_ERROR)
    {
        pAdapter=pAdapterInfo;
        while(pAdapter)
        {
            if(0 == strcmp(pAdapter->AdapterName,pCardName.c_str()))
            {
                for(int i = 0; i < pAdapter->AddressLength; i++)
                {
                    char buffer[256] = {0};
                    sprintf(buffer, "%02x", (unsigned char)pAdapter->Address[i]);
                    pMacAddress += buffer;
                    if(i != (pAdapter->AddressLength-1))
                    {
                        pMacAddress += "-";
                    }
                }
                break;
                /*
                printf("--------n");
                printf("AdapterName:t%sn",pAdapter->AdapterName);
                printf("AdapterDesc:t%sn",pAdapter->Description);
                printf("AdapterAddr:t");
                for(UINTi=0;i<pAdapter->AddressLength;i++)
                {
                    printf("%02X%c",pAdapter->Address[i],
                　　　　　　　　i==pAdapter->AddressLength-1?’n’:’-’);
                }
                printf("AdapterType:t%dn",pAdapter->Type);
                printf("IPAddress:t%sn",pAdapter->IpAddressList.IpAddress.String);
                printf("IPMask:t%sn",pAdapter->IpAddressList.IpMask.String);
                */
            }
        pAdapter=pAdapter->Next;
        }
    }
    else
    {
        return -1;
    }
    free(pAdapterInfo);
    return 0;
}



void ctow(WCHAR* Dest, const CHAR* Source)
{
    int i = 0;

    while(Source[i] != '\0')
    {
        Dest[i] = (WCHAR)Source[i];
        ++i;
    }
}
void wtoc(CHAR* Dest, const WCHAR* Source)
{
    int i = 0;

    while(Source[i] != '\0')
    {
        Dest[i] = (CHAR)Source[i];
        ++i;
    }
}

RegisterOps* RegisterOps::mInstancePtr = 0;

RegisterOps* RegisterOps::getInstance()
{
    if(mInstancePtr == 0)
    {
        mInstancePtr = new RegisterOps();
    }
    return mInstancePtr;

}

RegisterOps::RegisterOps()
{
    m_regFilePath = "C:\\WINDOWS\\system32\\config";
    m_regList.push_back(REG_SAM);
    m_regList.push_back(REG_SOFTWARE);
    m_regList.push_back(REG_SYSTEM);
    m_bUboot = false;
}

RegisterOps::~RegisterOps()
{
    m_bUboot = false;
}

int RegisterOps::read(char *pKey, char *pResult)
{
    return 0;
}

int RegisterOps::write(char *pKey, char *pResult)
{
   return 0;
} 

string RegisterOps::getComputerName(CString pKeyPrefix)
{
    CString lKey = (pKeyPrefix.GetLength() != 0)?
        (pKeyPrefix + "SYSTEM\\ControlSet001\\Control\\ComputerName\\ComputerName")
        :"SYSTEM\\ControlSet001\\Control\\ComputerName\\ComputerName";

    CReg lReg;
    lReg.SetRootKey(HKEY_LOCAL_MACHINE);
    lReg.SetKey(lKey, FALSE);

    return lReg.ReadString("ComputerName", "null").GetBuffer(0);
}

string RegisterOps::getComputerName()
{
  return getComputerName("");  
}

int RegisterOps::access(Action pAction, string pKey, char * pField, FiledType pType, ValueList &pResult)
{
//check key
    size_t pos_of_first_slash = 0;
    if(pos_of_first_slash = pKey.find_first_of('\\', 0))
    {
        if((0 != pKey.compare(0, pos_of_first_slash, "HKEY_LOCAL_MACHINE", 18))
            &&(0 != pKey.compare(0, pos_of_first_slash, "HKEY_CLASSES_ROOT", 17))
            &&(0 != pKey.compare(0, pos_of_first_slash, "HKEY_CURRENT_USER", 17))
            &&(0 != pKey.compare(0, pos_of_first_slash, "HKEY_USERS", 10)))
        {
            cout<<"registry key invalid"<<endl;
            return 1;
        }
    }
    else
    {
        cout<<"registry key invalid"<<endl;
        return 1;
    }

    formatHKey(pKey);
    
    if(ACT_USB_CLASS == pAction)
    {
        return getUsbClass(pResult, pKey.c_str());
    }
    if(ACT_USB_TYPE == pAction)
    {
        return getUsbType(pResult, pKey.c_str());
    }
    if(ACT_USB_HARDWAREID== pAction)
    {
        return getUsbHardwareId(pResult, pKey.c_str());
    }
    if(ACT_BHO == pAction)
    {
        return getBHO(pResult, pKey.c_str());
    }
    if(ACT_IE_SECURITY0 == pAction)
    {
        return getIESecurity(pResult, "0", pKey.c_str());
    }
    if(ACT_IE_SECURITY1 == pAction)
    {
        return getIESecurity(pResult, "1", pKey.c_str());
    }
    if(ACT_IE_SECURITY2 == pAction)
    {
        return getIESecurity(pResult, "2", pKey.c_str());
    }
    if(ACT_IE_SECURITY3 == pAction)
    {
        return getIESecurity(pResult, "3", pKey.c_str());
    }
    if(ACT_IE_SECURITY4 == pAction)
    {
        return getIESecurity(pResult, "4", pKey.c_str());
    }
    if(ACT_WIN_SHARES == pAction)
    {
        return getShares(pResult, pKey.c_str());
    }
    if(ACT_WIN_SYS_SHARES == pAction)
    {
        return getAutoShare(pResult, pKey.c_str(), pField, pType);
    }
    if(ACT_NETIF_NAME == pAction)
    {
        return getNetworkAdpterInfo(1, pResult, pKey.c_str());
    }
    if(ACT_NETIF_IP == pAction)
    {
        return getNetworkAdpterInfo(2, pResult, pKey.c_str());
    }
    if(ACT_NETIF_GW == pAction)
    {
        return getNetworkAdpterInfo(3, pResult, pKey.c_str());
    }
    if(ACT_NETIF_MASK == pAction)
    {
        return getNetworkAdpterInfo(4, pResult, pKey.c_str());
    }
    if(ACT_NETIF_MAC == pAction)
    {
        return getNetworkAdpterInfo(5, pResult, pKey.c_str());
    }
    if(ACT_NETIF_BLUETOOTH == pAction)
    {
        return getModemInfo(pResult, pKey.c_str(), pField, pType);
    }
    if(ACT_NETIF_BLUETOOTH_ID == pAction)
    {
        return getModemInfo(pResult, pKey.c_str(), pField, pType);
    }
    if(ACT_NETIF_WIRELESS_CARD == pAction)
    {
        return getWirelessCardName(pResult, pKey.c_str(), pField);
    }
    if(ACT_NETIF_WIRELESS_CARD_ID == pAction)
    {
        return getWirelessCardId(pResult, pKey.c_str(), pField);
    }
    if(ACY_NETIF_MODEM_NAME == pAction)
    {
        return getModemInfo(pResult, pKey.c_str(), pField, pType);
    }
    if(ACY_NETIF_MODEM_PORT == pAction)
    {
        return getModemInfo(pResult, pKey.c_str(), pField, pType);
    }
    if(ACY_NETIF_MODEM_ID == pAction)
    {
        return getModemInfo(pResult, pKey.c_str(), pField, pType);
    }
    if(ACT_WIN_SP_SOFTWARE == pAction)
    {
        if(true == getSP(pResult, pKey.c_str(), pField, pType))
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }
    if(ACT_SOFTWARE_INSTALL == pAction)
    {
        if(true == getSoftwareInstall(pResult, pKey.c_str(), pField, pType))
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }
    
    CReg Reg;

    Reg.SetRootKey(pKey);
    
    CString lKey(pKey.c_str());
    int flag = 0;
    if(lKey.GetLength() == (lKey.Find('*')+1))
    {
        lKey.Delete(lKey.Find('*'), 1);
        flag = 1;
    }
    std::string lResult;
    if (Reg.SetKey(lKey, FALSE))
    {
        if(ACT_READ == pAction)
        {
            if(flag)
            {
                ValueList lSubKeys;
                Reg.ReadSubKeys(lSubKeys);
                
                for(unsigned int i = 0; i < lSubKeys.size(); i++)
                {
                    CString key = lKey;
                    key += lSubKeys[i].c_str();

                    Reg.SetKey(key, false);
                    unsigned char *bins = NULL;
                    int len = 0;
                    if(Binary == pType)
                    {
                        ValueList lSubStr;
                        string val;
                        int j = 0;

                        if(!strcmp(pField, "DLLFile"))
                        {
                            Reg.ReadBinary("PackedCatalogItem", &bins, len);
                            val= (char*)(bins);
                            
                        }
                        else if(!strcmp(pField, "SPIProtocol"))
                        {
                            Reg.ReadBinary("PackedCatalogItem", &bins, len);
                            WSAPROTOCOL_INFOW *pInfo = (WSAPROTOCOL_INFOW*)(bins+MAX_PATH);
                            char lbuf[WSAPROTOCOL_LEN+1] = {0};
                            wtoc(lbuf, pInfo->szProtocol);
                            val = lbuf;
                        }
                        else if(!strcmp(pField, "Attr"))
                        {
                            Reg.ReadBinary("PackedCatalogItem", &bins, len);
                            WSAPROTOCOL_INFOW *pInfo = (WSAPROTOCOL_INFOW*)(bins+MAX_PATH);
                            char lbuf[8+1] = {0};
                            sprintf(lbuf, "%#08x", pInfo->dwServiceFlags1);
                            val = lbuf;
                        }

                        pResult.push_back(val);
                    }

                }

                return 0;
            }
            else if(0 == strcmp(KEY_WILDCARD, pField))
            {
                ValueList lValues;
                Reg.ReadKeyValues(pResult);
                for(DWORD i = 0; i < pResult.size(); i++)
                {
                    cout<<pResult[i]<<endl;
                }
                return 0;
            }
            
            if(Binary == pType)
            {
                unsigned char *buffer = NULL;
                int lLen = 0;
                Reg.ReadBinary(pField, &buffer, lLen);
                if(lLen != 0 )
                {
//                    lResult.assign(buffer);
                }
                else
                {
                    lResult.assign(" ");
                }
            }
            else if(DWord == pType)
            {
                DWORD lVal;
                lVal = Reg.ReadDword(pField, -1);
                char str[32] = {0};
                sprintf(str, "%d", lVal);
                lResult.assign(str);
            }
            else if(KString == pType)
            {
                CString lVal = Reg.ReadString(pField, " ");
                lResult.assign(lVal.GetBuffer(0));
            }
            else if(MString == pType)
            {
                CString lVal = Reg.ReadMutilString(pField, "", " ");
                lResult.assign(lVal.GetBuffer(0));
            }
            
            pResult.push_back(lResult);
        }
        else if(ACT_ALL_FILEDS == pAction)
        {
            Reg.ReadKeyValueNames(pResult);
        }
        else if(ACT_SUBKEYS == pAction)
        {
            Reg.ReadSubKeys(pResult);
        }
        else if(ACT_SUBKEYS_TOTALPATH == pAction)
        {
            ValueList lSubKeys;
            Reg.ReadSubKeys(lSubKeys);
            for(unsigned int i = 0; i < lSubKeys.size(); i++)
            {
                CString ltmp = pKey.c_str();
                ltmp += lSubKeys[i].c_str();
                pResult.push_back(ltmp.GetBuffer(0));
            }
        }
        /*
        else if(ReadValues == pAction)
        {
            Reg.ReadKeyValues(pResult);
        }
        */
    }
    else
    {
        cout<<"Failed to open key : "<<pKey<<endl;
        return 1;
    }
    return 0; 
}


bool RegisterOps::getShares(ValueList & pShares, CString pKey)
{
    ValueList lKeys;
    dilemeterKey(pKey.GetBuffer(0), lKeys);

    if(lKeys.size() !=5)
    {
        return false;
    }
    
    string lSet001 = lKeys[0].c_str();
    string lSet002 = lKeys[1].c_str();
    string lSet003 = lKeys[2].c_str();
    string lCtrlSet = lKeys[3].c_str();

    string lSelect = lKeys[4].c_str();

    CReg Reg;
    Reg.SetRootKey(lSet001);
    Reg.SetRootKey(lSet002);
    Reg.SetRootKey(lSet003);
    Reg.SetRootKey(lCtrlSet);
    Reg.SetRootKey(lSelect);

    
    DWORD lSel;

    ValueList lShareDirs;
    ValueList lPaths;


    Reg.SetRootKey(HKEY_LOCAL_MACHINE);

    Reg.SetKey(lSelect.c_str(), FALSE);

    lSel = Reg.ReadDword("Current", 0);

    Reg.SetKey(lCtrlSet.c_str(), FALSE);
    lShareDirs.clear();
    Reg.ReadKeyValueNames(lShareDirs);
    for(unsigned int i = 0; i < lShareDirs.size(); i++)
    {
        
        CString lPath = Reg.ReadMutilString(lShareDirs[i].c_str(), "Path", "null");
        int loc = lPath.Find('=');
        if(loc>0)
        {
            lPath.Delete(0, loc+1);
            pShares.push_back(lPath.GetBuffer(0));
        }
    }

    return true;
}
bool RegisterOps::getBHO(ValueList & pBHOs, CString pKey)
{
    CString lCLSID;
    CString lKey = "\\InprocServer32";
    CString lBHOs ;
    
    ValueList lKeys;
    dilemeterKey(pKey.GetBuffer(0), lKeys);
    string CLSID = lKeys[0].c_str();
    string BHOs = lKeys[1].c_str();
    
    CReg lReg;

    lReg.SetRootKey(CLSID);
    lReg.SetRootKey(BHOs);

    lCLSID = CLSID.c_str();
    lBHOs = BHOs.c_str();

    if(lReg.SetKey(lBHOs, false) == TRUE)
    {
        ValueList lSubKeys;
        if(TRUE == lReg.ReadSubKeys(lSubKeys))
        {
            for(unsigned int i = 0; i < lSubKeys.size(); i++)
            {
                CString lTmp = lSubKeys[i].c_str();
                CString lCLSIDKey = lCLSID + "\\" + lTmp + lKey;

                if(lReg.SetKey(lCLSIDKey, false) == TRUE)
                {
                    CString lBHO;
                    if(TRUE == lReg.ReadDefaultValue(lBHO))
                    {
                        string tmp = lBHO.GetBuffer(0);
                        
//                        cout<<"BHO : "<<tmp<<endl;
                        pBHOs.push_back(tmp);
                    }
                }
                else
                {
                    //failed
                    return false;
                }
            }
        }
        else
        {
            //failed
            return false;
        }
    }
    else
    {
        //failed
        return false;
    }

    
    return true;
}

bool RegisterOps::_getSelectedResult(CString pKey, CString pZone, string &pResult, string pZones)
{
    CReg lReg;
    CString lZones = pZones.c_str();

    lReg.SetRootKey(HKEY_LOCAL_MACHINE);

    if(lReg.SetKey(pKey, false))
    {
        CString lType = lReg.ReadString("Type", "");
        CString lGroup = "group";
        if(lType != lGroup)
        {
            return false;
        }

        ValueList lOptions;
        if(lReg.ReadSubKeys(lOptions))
        {
//            for(unsigned int i = 0; i < lOptions.size(); i++)
            {
                CString lOption;
                lOption += pKey;
                lOption += "\\";
                lOption += lOptions[0].c_str();
                
                if(lReg.SetKey(lOption, false))
                {
                    CString lValueName = lReg.ReadString("ValueName", "");
                    lZones += "\\";
                    lZones += pZone;

                    if(lReg.SetKey(lZones, false))
                    {
                        DWORD lRes = lReg.ReadDword(lValueName, 100);
                        if(lReg.SetKey(pKey, false))
                        {
                            for(unsigned int i = 0; i < lOptions.size(); i++)
                            {
                                CString lOpt;
                                lOpt += pKey;
                                lOpt += "\\";
                                lOpt += lOptions[i].c_str();
                                
                                if(lReg.SetKey(lOpt, false))
                                {
                                    DWORD lValue = lReg.ReadDword("CheckedValue", 100);
                                    if(lValue == lRes)
                                    {
                                        CString lResultStr = lReg.ReadString("Text", "");
                                        pResult = lResultStr.GetBuffer(0);
                                        break;
                                    }
                                }
                            }
                            
                        }

                        return true;
                    }
                }
            }
        }
    }

    return false;
}

bool RegisterOps::_isKeyItemGroup(CString pKey)
{
    CReg lReg;
    lReg.SetRootKey(HKEY_LOCAL_MACHINE);

    if(lReg.SetKey(pKey, false))
    {
        ValueList lOptions;
        if(lReg.ReadSubKeys(lOptions))
        {
            for(unsigned int i = 0; i < lOptions.size(); i++)
            {
                CString lOption;
                lOption += pKey;
                lOption += "\\";
                lOption += lOptions[i].c_str();

                if(lReg.SetKey(lOption, false))
                {
                    CString lRadioType = "radio";
                    CString lType = lReg.ReadString("Type", "");

                    if(lType == lRadioType)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        else
        {
            cout<<"ReadSubKey "<<pKey<<" failed"<<endl;
        }
    }
    else
    {
        cout<<"setKey "<<pKey<<" failed"<<endl;
    }

    return false;
}


bool RegisterOps::dilemeterKey(string pKeys, ValueList & pKey)
{
    string key = pKeys;
    size_t first_delimeter = 0;
    size_t start = 0;
    do
    {
        string ltmp ;
        first_delimeter = key.find(';', start);
        if((size_t)(-1) == first_delimeter)
        {
            ltmp.assign(key, start, key.length ()-start);
        }
        else
        {
            ltmp.assign(key, start, first_delimeter-start);
            start = first_delimeter+1;
        }
        pKey.push_back(ltmp);
    }while((size_t)(-1) != first_delimeter);

   return true;
}

bool RegisterOps::getIESecurity(ValueList & pResults, CString pZone, CString pKey)
{
   string key = pKey.GetBuffer(0);
   ValueList lKeys;
   
   dilemeterKey(key, lKeys);
   
   /*
   size_t first_delimeter = 0;

   if(0 > (first_delimeter = key.find_first_of(';', 0)))
   {
      return false;
   }
   */
   if(lKeys.size() != 2)
   {
      return false;
   }
   string cContent;
//   cContent.assign(key, 0, first_delimeter);
   cContent = lKeys[0];

   
   string cZones ;
//   cZones.assign(key.data()+ first_delimeter+1, key.length()-first_delimeter-1);
   cZones = lKeys[1];
   
   CReg lReg;

   lReg.SetRootKey(cContent);
   lReg.SetRootKey(cZones);

   CString lZones = cZones.c_str();
   CString lContent = cContent.c_str();
   
   if(lReg.SetKey(lContent, false))
   {
        ValueList lSubContents;
        lReg.ReadSubKeys(lSubContents);

        for(unsigned int i = 0; i < lSubContents.size(); i++) 
        {
            CString lSubContent = lSubContents[i].c_str();
            cout<<"content "<<lSubContents[i]<<endl;

            pResults.push_back(lSubContent.GetBuffer(0));

            if(lReg.SetKey(lContent+ "\\" +lSubContent, false)) // ACTIVE_CONTENT, AUTH, DOTNET.... 
            {
                CString lItemDisplay = lReg.ReadString("Text", ""); // display name
                cout<<"    content display "<<lItemDisplay.GetBuffer(0)<<endl;
                CString lTmp1 = "    ";//   2 space 
                lTmp1 += lItemDisplay;
                
                
                CString lKey = lContent+ "\\" +lSubContent;
                if(_isKeyItemGroup(lKey))
                {
                    string res;
                    CString lTem = lContent + "\\" + lSubContent;
                    
                    _getSelectedResult(lTem, pZone, res, cZones);
                    cout<<"        result : "<<res << endl;
                    lTmp1 += " : ";
                    lTmp1 += res.c_str();
                    pResults.push_back(lTmp1.GetBuffer(0));
                }
                else
                {
                    pResults.push_back(lTmp1.GetBuffer(0));
                    ValueList lItems;
                    
                    lReg.ReadSubKeys(lItems);

                    for(unsigned int j = 0; j<lItems.size(); j++) 
                    {
                        CString lItem =  lItems[j].c_str();
                        cout<<"       item "<<lItem;
                        CString lTmp = "        "; // 4 spaces
                        lTmp += lItem;
                        
                        
                        CString lTemKey = lContent + "\\" + lSubContent + "\\" + lItem;
                        
                        if(_isKeyItemGroup(lTemKey.GetBuffer(0)))
                        {
                            string res;
                            _getSelectedResult(lTemKey.GetBuffer(0), "0", res, cZones);
                            cout<<" : "<<res << endl;
                            lTmp += " : ";
                            lTmp += res.c_str();
                        }
                        else
                        {
                            cout<<" error ******** "<<lTemKey.GetBuffer(0)<<endl;
                        }

                        pResults.push_back(lTmp.GetBuffer(0));
                    }
                }

            }
            else
            {
                cout<<"SetKey "<<lContent+ "\\" +lSubContent<<" failed"<<endl;
            }
            

        }
    
   }
   else
   {
      cout <<"SetKey "<<lContent<< "failed"<<endl;
   }
   return true;
}

bool RegisterOps::getUsbClass(ValueList &pResult, CString pKey)
{
    string lKey = pKey.GetBuffer(0);

    CReg lReg;
    lReg.SetRootKey(lKey);

    lReg.SetKey(lKey.c_str(), FALSE);

    ValueList lSubs;
    lReg.ReadSubKeys(lSubs);

    for(unsigned int i = 0; i < lSubs.size(); i++)
    {
        CString lUsbKey = lKey.c_str();
        lUsbKey += "\\";

        lUsbKey += lSubs[i].c_str();

        lReg.SetKey(lUsbKey, FALSE);
        
        ValueList lSubDevs;
        lReg.ReadSubKeys(lSubDevs);
        for(unsigned int j = 0; j < lSubDevs.size(); j++)
        {
            CString lDev = lUsbKey;
            lDev += "\\";

            lDev += lSubDevs[j].c_str();

            lReg.SetKey(lDev, FALSE);

            CString lClass = lReg.ReadString("DeviceDesc", "USB");

            pResult.push_back(lClass.GetBuffer(0));
            
        }
        
    }

    return true;
    
}


bool RegisterOps::getUsbType(ValueList &pResult, CString pKey)
{
    string lKey = pKey.GetBuffer(0);

    CReg lReg;

    if(TRUE != lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE != lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }

    ValueList lSubs;
    lReg.ReadSubKeys(lSubs);

    for(unsigned int i = 0; i < lSubs.size(); i++)
    {
        CString lUsbKey = lKey.c_str();
        lUsbKey += "\\";

        lUsbKey += lSubs[i].c_str();

        lReg.SetKey(lUsbKey, FALSE);
        
        ValueList lSubDevs;
        lReg.ReadSubKeys(lSubDevs);
        for(unsigned int j = 0; j < lSubDevs.size(); j++)
        {
            CString lDev = lUsbKey;
            lDev += "\\";

            lDev += lSubDevs[j].c_str();

            lReg.SetKey(lDev, FALSE);

            CString lClass = lReg.ReadString("FriendlyName", "USB");

            pResult.push_back(lClass.GetBuffer(0));
            
        }
        
    }

    return true;
    
}



bool RegisterOps::getUsbHardwareId(ValueList &pResult, CString pKey)
{
    string lKey = pKey.GetBuffer(0);

    CReg lReg;

    if(TRUE != lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE != lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }

    ValueList lSubs;
    lReg.ReadSubKeys(lSubs);

    for(unsigned int i = 0; i < lSubs.size(); i++)
    {
        CString lUsbKey = lKey.c_str();
        lUsbKey += "\\";

        lUsbKey += lSubs[i].c_str();

        lReg.SetKey(lUsbKey, FALSE);
        
        ValueList lSubDevs;
        lReg.ReadSubKeys(pResult);
/*
        return true;
        for(unsigned int j = 0; j < lSubDevs.size(); j++)
        {
            CString lDev = lUsbKey;
            lDev += "\\";

            lDev += lSubDevs[j].c_str();

            lReg.SetKey(lDev, FALSE);

            CString lClass = lReg.ReadString("HardwareID", "USB");

            pResult.push_back(lClass.GetBuffer(0));
            
        }
*/
    }

    return true;
    
}

/*

key  :  1 card name
        2 : ip address
        3 : gateway
        4 : mask
        5 : mac
*/
bool RegisterOps::getNetworkAdpterInfo(int key, ValueList & pResult, CString pKeys)
{
    string lNetworkCard;

    CReg lReg;
    ValueList lCards;

    string lInterfaceBase;

    ValueList lKeys;
    dilemeterKey(pKeys.GetBuffer(0), lKeys);

    if(lKeys.size() != 2)
    {
        return false;
    }
    lNetworkCard = lKeys[0];
    lInterfaceBase = lKeys[1];


    lReg.SetRootKey(lNetworkCard);
    lReg.SetRootKey(lInterfaceBase);

    if(TRUE!=lReg.SetKey(lNetworkCard.c_str(), FALSE))
    {
        return false;
    }

    lReg.ReadSubKeys(lCards);

    for(unsigned int nCard = 0; nCard < lCards.size(); nCard++)
    {
        CString lServiceName = lNetworkCard.c_str();

        lServiceName += "\\";

        lServiceName += lCards[nCard].c_str();

        lReg.SetKey(lServiceName, FALSE);

        if(key == 1) // card name
        {
            CString lCardDes = lReg.ReadString("Description", "null");
            pResult.push_back(lCardDes.GetBuffer(0));
        }
        else if(key == 2)//IP address
        {
            CString lCardServName = lReg.ReadString("ServiceName", "null");

            CString lInterface = lInterfaceBase.c_str();
            lInterface = lInterface + "\\" + lCardServName;

            lReg.SetKey(lInterface, FALSE);

            CString lIpAddress;

            if(lReg.ReadDword("EnableDHCP", 0))
            {
                lIpAddress = lReg.ReadString("DhcpIPAddress", "0.0.0.0");
            }
            else
            {
                lIpAddress = lReg.ReadMutilString("IPAddress", "", "0.0.0.0");
            }

            pResult.push_back(lIpAddress.GetBuffer(0));
        }
        else if(key == 3)//gateway address
        {
            CString lCardServName = lReg.ReadString("ServiceName", "null");

            CString lInterface = lInterfaceBase.c_str();
            lInterface = lInterface + "\\" + lCardServName;

            lReg.SetKey(lInterface, FALSE);

            CString lGateway;
            if(lReg.ReadDword("EnableDHCP", 0))
            {
                lGateway = lReg.ReadMutilString("DhcpDefaultGateway", "", "0.0.0.0");
            }
            else
            {
                lGateway = lReg.ReadMutilString("DefaultGateway", "", "0.0.0.0");
            }
            pResult.push_back(lGateway.GetBuffer(0));
        }
        else if(key == 4)//network mask
        {
            CString lCardServName = lReg.ReadString("ServiceName", "null");

            CString lInterface = lInterfaceBase.c_str();
            lInterface = lInterface + "\\" + lCardServName;

            lReg.SetKey(lInterface, FALSE);

            CString lMask;
            if(lReg.ReadDword("EnableDHCP", 0))
            {
                lMask = lReg.ReadString("DhcpSubnetMask", "0.0.0.0");
            }
            else
            {
                lMask = lReg.ReadString("SubnetMask", "0.0.0.0");
            }
            pResult.push_back(lMask.GetBuffer(0));
        }
        else if(key == 5)//mac
        {
            CString lCardServName = lReg.ReadString("ServiceName", "null");
            string lMac;

            getNetworkCardMac(lCardServName.GetBuffer(0), lMac);
            pResult.push_back(lMac);
        }
    }
    return true;
}

string RegisterOps::getCheckingIpAddress()
{
    ValueList lIpaddress;
    Titles lTitles;
    XmlTree::getInstance()->nodeParse("网络配置信息", &lTitles);
    
    string lKeys = lTitles[0]->getKey(0);
    
    RegisterOps::getInstance()->getNetworkAdpterInfo(2, lIpaddress, 
        lKeys.c_str());

    for(unsigned int i = 0; i < lIpaddress.size(); i++)
    {
        if(lIpaddress[i] != "0.0.0.0")
        {
            return lIpaddress[i];
        }

    }

    return "0.0.0.0";
}

bool RegisterOps::getBlueToothName(ValueList &pResult, string pKeys, char * pField)
{
    ValueList lKeys;

    dilemeterKey(pKeys, lKeys);

    string lKey = lKeys[0];
    string lKeyWord = lKeys[1];

    CReg lReg;

    if(TRUE!=lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE!=lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }
    ValueList lSubKeys;
    lReg.ReadSubKeys(lSubKeys);

    for(unsigned int i = 0 ; i < lSubKeys.size(); i++)
    {
        string lsubkey = lKey + "\\" + lSubKeys[i];

        lReg.SetKey(lsubkey.c_str(), FALSE);

        string lClass = lReg.ReadString(pField, "null").GetBuffer(0);

        if(lClass.find(lKeyWord.c_str()) != (unsigned int)(-1))
        {
            CString lName;
            lReg.ReadDefaultValue(lName);
            pResult.push_back(lName.GetBuffer(0));
        }
    }


    return true;
}
bool RegisterOps::getBlueToothId(ValueList &pResult, string pKeys, char * pField)
{
    ValueList lKeys;

    dilemeterKey(pKeys, lKeys);

    string lKey = lKeys[0];
    string lKeyWord = lKeys[1];

    CReg lReg;

    if(TRUE!=lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE!=lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }
    ValueList lSubKeys;
    lReg.ReadSubKeys(lSubKeys);

    for(unsigned int i = 0 ; i < lSubKeys.size(); i++)
    {
        string lsubkey = lKey + "\\" + lSubKeys[i];

        lReg.SetKey(lsubkey.c_str(), FALSE);

        string lClass = lReg.ReadString(pField, "null").GetBuffer(0);

        if(lClass.find(lKeyWord.c_str()) != (unsigned int)(-1))
        {
            pResult.push_back(lSubKeys[i]);
        }
    }


    return true;
}
bool RegisterOps::getWirelessCardName(ValueList &pResult, string pKeys, char * pField)
{
    ValueList lKeys;

    dilemeterKey(pKeys, lKeys);

    string lKey = lKeys[0];
    string lKeyWord = lKeys[1];

    CReg lReg;

    if(TRUE!=lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE!=lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }
    ValueList lSubKeys;
    lReg.ReadSubKeys(lSubKeys);

    for(unsigned int i = 0 ; i < lSubKeys.size(); i++)
    {
        string lsubkey = lKey + "\\" + lSubKeys[i];

        if(TRUE != lReg.SetKey(lsubkey.c_str(), FALSE))
        {
            continue;
        }

        string lClass = lReg.ReadString(pField, "null").GetBuffer(0);
        
        if(lClass  == "null" )
            continue;

        if(lClass == lKeyWord.c_str())
        {
            string lCardkey;
//            lReg.SetKey(lCardkey.c_str(), FALSE);
            ValueList lConnections;
            lReg.ReadSubKeys(lConnections);

            for (unsigned int num = 0; num < lConnections.size(); num++)
            {
                lCardkey = lsubkey + "\\" + lConnections[num] + "\\" + lKeys[2];
                if(TRUE!=lReg.SetKey(lCardkey.c_str()))
                {
                    continue;
                }

                DWORD lMedia = lReg.ReadDword(lKeys[3].c_str(), 0);
                if(2 == lMedia)
                {
                    CString lName = lReg.ReadString(lKeys[4].c_str(), " ");
                    pResult.push_back(lName.GetBuffer(0));
                }
            }
            
            
        }
    }


    return true;
}
bool RegisterOps::getWirelessCardId(ValueList &pResult, string pKeys, char * pField)
{
    ValueList lKeys;

    dilemeterKey(pKeys, lKeys);

    string lKey = lKeys[0];
    string lKeyWord = lKeys[1];

    CReg lReg;

    if(TRUE!=lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE!=lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }
    ValueList lSubKeys;
    lReg.ReadSubKeys(lSubKeys);

    for(unsigned int i = 0 ; i < lSubKeys.size(); i++)
    {
        string lsubkey = lKey + "\\" + lSubKeys[i];

        if(TRUE!=lReg.SetKey(lsubkey.c_str(), FALSE))
        {
            continue;
        }

        string lClass = lReg.ReadString(pField, "null").GetBuffer(0);

        if(lClass == lKeyWord.c_str())
        {
            string lCardkey ;
//            lReg.SetKey(lCardkey.c_str(), FALSE);
            ValueList lConnections;
            lReg.ReadSubKeys(lConnections);

            for (unsigned int num = 0; num < lConnections.size(); num++)
            {
                lCardkey = lsubkey + "\\" + lConnections[num] + "\\" + lKeys[2];
                lReg.SetKey(lCardkey.c_str());

                DWORD lMedia = lReg.ReadDword(lKeys[3].c_str(), 0);
                if(2 == lMedia)
                {
                    CString lID = lReg.ReadString(lKeys[4].c_str(), " ");
                    pResult.push_back(lID.GetBuffer(0));
                }
            }
            
        }
    }


    return true;
}

bool RegisterOps::getModemInfo(ValueList &pResult, string pKeys, char * pField, FiledType pType)
{
    ValueList lKeys;

    dilemeterKey(pKeys, lKeys);

    string lKey = lKeys[0];
    string lKeyWord = lKeys[1];

    CReg lReg;

    if(TRUE!= lReg.SetRootKey(lKey))
    {
        return false;
    }

    if(TRUE!=lReg.SetKey(lKey.c_str(), FALSE))
    {
        return false;
    }
    ValueList lSubKeys;
    lReg.ReadSubKeys(lSubKeys);

    for(unsigned int i = 0 ; i < lSubKeys.size(); i++)
    {
        string lsubkey = lKey + "\\" + lSubKeys[i];

        if(TRUE!=lReg.SetKey(lsubkey.c_str(), FALSE))
            continue;

        string lClass = lReg.ReadString(pField, "null").GetBuffer(0);
        
        if(lClass  == "null" )
            continue;

        if(lClass == lKeyWord.c_str())
        {
            string lCardkey;
//            lReg.SetKey(lCardkey.c_str(), FALSE);
            ValueList lConnections;
            lReg.ReadSubKeys(lConnections);

            for (unsigned int num = 0; num < lConnections.size(); num++)
            {
                lCardkey = lsubkey + "\\" + lConnections[num];// + "\\" + lKeys[2];
                lReg.SetKey(lCardkey.c_str());

                CString lstr = lReg.ReadString(lKeys[2].c_str(), " ");
                {
                    pResult.push_back(lstr.GetBuffer(0));
                }
            }
            
            
        }
    }


    return true;
}
bool RegisterOps::readValue(string pKey, char * pField, FiledType pType, string & res)
{
    CReg Reg;
    string lResult;

    if(Reg.SetRootKey(pKey))
    {
        if(TRUE != Reg.SetKey(pKey.c_str(), FALSE))
        {
            return false;
        }
        switch(pType)
        {
            case Binary:
            {
                unsigned char *buffer = NULL;
                int lLen = 0;
                Reg.ReadBinary(pField, &buffer, lLen);
                if(lLen != 0 )
                {
                    lResult.assign((char*)buffer);
                }
                else
                {
                    lResult.assign(" ");
                }
            }
            case DWord:
            {
                DWORD lVal;
                lVal = Reg.ReadDword(pField, -1);
                char str[32] = {0};
                sprintf(str, "%d", lVal);
                lResult.assign(str);
            }
            case KString :
            {
                CString lVal = Reg.ReadString(pField, " ");
                lResult.assign(lVal.GetBuffer(0));
            }
            case MString :
            {
                CString lVal = Reg.ReadMutilString(pField, "", " ");
                lResult.assign(lVal.GetBuffer(0));
            }
            default:
            {
                return false;
            }
        }

        res = lResult;
    }
    else
    {
        
        return false;
    }

    return true;
}
bool RegisterOps::getAutoShare(ValueList &pResult, string pKeys, char * pField, FiledType pType)
{
    string lres;

    if(readValue(pKeys, pField, pType, lres))
    {
        if(lres == "0")
        {
            pResult.push_back("未共享");
        }
        else
        {
            pResult.push_back("已共享");
        }
    }
    else
    {
        pResult.push_back("已共享");
    }

    return true;
}

bool RegisterOps::getSP(ValueList &PResult, string pKey, char * pField, FiledType pType)
{
    CReg lReg;

    lReg.SetRootKey(pKey);

    CString lUpdates = pKey.c_str();
    
    //lReg.SetRootKey(HKEY_LOCAL_MACHINE);

    ValueList lSoftware ;

    if(TRUE!=lReg.SetKey(lUpdates, FALSE))
    {
        return false;
    }

    if(TRUE!=lReg.ReadSubKeys(lSoftware))
    {
        return false;
    }

    for(unsigned int i = 0; i < lSoftware.size(); i++)
    {
        CString res = lSoftware[i].c_str();
//        PResult.push_back(res.GetBuffer(0));
        
        CString lCls = lUpdates;
        lCls += "\\";
        lCls += lSoftware[i].c_str();
        if(TRUE!=lReg.SetKey(lCls, FALSE))
        {
            return false;
        }

        if(lReg.GetSubKeyCount() == 0)
        {
            res += DELIMITER" ";
            res += DELIMITER" ";
            res += DELIMITER" ";
            PResult.push_back(res.GetBuffer(0));
        }
        else
        {
            ValueList lSPs;
            lReg.ReadSubKeys(lSPs);

            for(unsigned int j = 0; j < lSPs.size(); j++)
            {
                CString key = lCls;
                CString lDes, lDate;
                if(strncmp(lSPs[j].c_str(), "SP", 2) == 0)
                {
                    ValueList lSPSPs;
                    //skip this
                    key += "\\";

                    key += lSPs[j].c_str();

                    lReg.SetKey(key, FALSE);

                    lReg.ReadSubKeys(lSPSPs);

                    for(unsigned int k = 0; k < lSPSPs.size(); k++)
                    {
                        res += DELIMITER;
                        res += lSPSPs[k].c_str();
                        
                        key += "\\";
                        key += lSPSPs[k].c_str();
                        lReg.SetKey(key, FALSE);
                        
                        lDes = lReg.ReadString("Description", " ");
                        lDate = lReg.ReadString("InstalledDate", " ");

                        res += DELIMITER;
                        res += lDes;

                        res += DELIMITER;
                        string ldatestr = formatDate(lDate.GetBuffer(0));
                        res += ldatestr.c_str();
                    
                        PResult.push_back(res.GetBuffer(0));
                        res = lSoftware[i].c_str();

                    }
                }
                else
                {
                    res += DELIMITER;
                    res += lSPs[j].c_str();
                    
                    key += "\\";
                    key += lSPs[j].c_str();
                    
                    lReg.SetKey(key, FALSE);

                    lDes = lReg.ReadString("Description", " ");
                    lDate = lReg.ReadString("InstalledDate", " ");

                    res += DELIMITER;
                    res += lDes;

                    res += DELIMITER;
                    string ldatestr = formatDate(lDate.GetBuffer(0));
                    res += ldatestr.c_str();
                    
                    PResult.push_back(res.GetBuffer(0));
                    res = lSoftware[i].c_str();
                }
            }
        }
    }
    return true;
}

bool RegisterOps::RegLoad(HKEY hKey, bool bCurUserFlag)
{
    int ret = 0;
    //LPCSTR sFSReg = "test";
    //LPCSTR file = "C:\\WINDOWS\\repair\\software";
    LPCSTR file;
    LPCSTR file2;
    LPCSTR sFSReg;
    
    HANDLE htok = NULL; 
    OpenProcessToken(GetCurrentProcess(), 
    TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
    &htok); 
    TOKEN_PRIVILEGES tp0; 
    tp0.PrivilegeCount = 1; 
    tp0.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
    LUID luid0 ; 
    LookupPrivilegeValue(0,SE_BACKUP_NAME,&luid0); 
    tp0.Privileges[0].Luid = luid0; 

    if(!AdjustTokenPrivileges( htok, FALSE, &tp0, sizeof(tp0),0,0)) 
    {
        printf("AdjustTokenPrivilegs tp0 error! %d\n",GetLastError()); 
    }

    TOKEN_PRIVILEGES tp1; 
    tp1.PrivilegeCount = 1; 
    tp1.Privileges->Attributes = SE_PRIVILEGE_ENABLED; 
    LUID luid1 ; 
    LookupPrivilegeValue(0,SE_RESTORE_NAME,&luid1); 
    tp1.Privileges->Luid = luid1; 

    if(!AdjustTokenPrivileges( htok, FALSE, &tp1, sizeof(tp1), NULL,NULL)) 
    {
        printf("AdjustTokenPrivilegs tp1 error! %d\n",GetLastError()); 
    }

    CloseHandle(htok); 
    //if(!(ret = RegLoadKey(HKEY_LOCAL_MACHINE, sFSReg , file))) 
    if (!bCurUserFlag)
    {
        for (int i = 0; i < m_regList.size(); i++)
        {
            string s1 = m_regFilePath + "\\" + m_regList[i];
            file = s1.c_str();
            string s2 = REG_KEY_PREFIX + m_regList[i]; 
            sFSReg = s2.c_str();
            
            if(!(ret = RegLoadKey(hKey, sFSReg , file))) 
            {
                printf("导入成功!\n"); 
                //return true;
            }
            else 
            {
                printf("RegLoadKey error! %d\n", ret); 
                return false;
            }
        }
    }
    else
    {
        sFSReg = REG_KEY_CUR_NEWNAME;
        string s1 = CSysConfig::getInstance()->get_detectedDrive();
        s1 += "\\Documents and Settings\\";
        s1 += CSysConfig::getInstance()->get_detectedUser();
        s1 += "\\NTUSER.DAT";
        
        file2 = s1.c_str();
        if(!(ret = RegLoadKey(hKey, sFSReg , file2))) 
        {
            printf("导入成功!\n"); 
            ValueList lList;
            lList.push_back(s1);
            FileOps::getInstance()->writeToFile("error.log", lList);
            //return true;
        }
        else 
        {
            printf("RegLoadKey error! %d\n", ret); 
            return false;
        }
    }
    
    m_bUboot = true;
    return true;
}

bool RegisterOps::RegUnLoad(HKEY hKey)
{
    DWORD ret;
    HANDLE htok = NULL; 
    
    LPCSTR sFSReg;
    LPCSTR file;
    LPCSTR file2;
    OpenProcessToken(GetCurrentProcess(),  
        TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,  
        &htok);
    TOKEN_PRIVILEGES tp0;
    tp0.PrivilegeCount = 1;
    tp0.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    LUID luid0 ;
    LookupPrivilegeValue(0,SE_BACKUP_NAME,&luid0);
    tp0.Privileges[0].Luid = luid0;

    if(!AdjustTokenPrivileges( htok, FALSE, &tp0, sizeof(tp0),0,0))
        printf("AdjustTokenPrivilegs tp0 error! %d\n",GetLastError());


    TOKEN_PRIVILEGES tp1;
    tp1.PrivilegeCount = 1;
    tp1.Privileges->Attributes = SE_PRIVILEGE_ENABLED;
    LUID luid1 ;
    LookupPrivilegeValue(0,SE_RESTORE_NAME,&luid1);
    tp1.Privileges->Luid = luid1;
    if(!AdjustTokenPrivileges( htok, FALSE, &tp1, sizeof(tp1), NULL,NULL))
        printf("AdjustTokenPrivilegs tp1 error! %d\n",GetLastError());
    CloseHandle(htok);

    //unload
     for (int i = 0; i < m_regList.size(); i++)
    {
        string s2 = REG_KEY_PREFIX + m_regList[i]; 
        sFSReg = s2.c_str();
        
        if(!(ret = RegUnLoadKey(hKey, sFSReg))) 
        {
            printf("卸载成功!\n"); 
            //return true;
        }
        else 
        {
            printf("卸载失败!\n", ret); 
            return false;
        }
    }

        ValueList lList;
    sFSReg = REG_KEY_CUR_NEWNAME;
    if(!(ret = RegUnLoadKey(hKey, sFSReg))) 
    {
        printf("卸载成功!\n"); 
        lList.push_back("xxxxxxxxxxx");
        FileOps::getInstance()->writeToFile("error2.log", lList);

        //return true;
    }
    else 
    {
        printf("RegLoadKey error! %d\n", ret); 
        lList.push_back("yyyyyyyyyyyy");
        FileOps::getInstance()->writeToFile("error2.log", lList);
        return false;
    }
    
    return true; 
}

void RegisterOps::formatHKey(string& pKey)
{
    StringEx oStr;
    
    if (m_bUboot)
    {
            size_t pos_of_first_slash = 0;
            if(pos_of_first_slash = pKey.find_first_of('\\', 0))
            {
                /*将HKEY_LOCAL_MACHINE分支替换*/
                if(0 == pKey.compare(0, pos_of_first_slash, "HKEY_LOCAL_MACHINE", 18))
                {
                    string s1 = "HKEY_LOCAL_MACHINE\\";
                    s1 += REG_KEY_PREFIX;

                    if (strcmp(pKey.substr(19, 8).c_str(), "HARDWARE") != 0) /*跳过HARDWARE分支,以便能检测到CPU等硬件信息*/
                    {
                        oStr.string_replace(pKey, "HKEY_LOCAL_MACHINE\\", s1);
                    }
                    
                    oStr.string_replace(pKey, "CurrentControlSet", "ControlSet001");
                }

                /*将HKEY_CURRENT_USER分支替换*/
                if(0 == pKey.compare(0, pos_of_first_slash, "HKEY_CURRENT_USER", 17))
                {
                    string s1 = "HKEY_LOCAL_MACHINE\\";
                    s1 += REG_KEY_CUR_NEWNAME;
                    s1 += "\\";
                    oStr.string_replace(pKey, "HKEY_CURRENT_USER\\", s1);
                }

            }
    }
}

bool RegisterOps::getSoftwareInstall(ValueList &PResult, string pKey, char * pField, FiledType pType)
{
    CReg lReg;

    lReg.SetRootKey(pKey);
    CString lUninstall = pKey.c_str();
    
    ValueList lSoftwares ;

    if(TRUE != lReg.SetKey(lUninstall, FALSE))
    {
        return FALSE;
    }

    if(lReg.ReadSubKeys(lSoftwares) != TRUE)
    {
        return FALSE;
    }

    for(unsigned int i = 0; i < lSoftwares.size(); i++)
    {
//        PResult.push_back(res.GetBuffer(0));
        CString res ;
        
        CString lSoftware = lUninstall;
        lSoftware += "\\";
        lSoftware += lSoftwares[i].c_str();
        
        lReg.SetKey(lSoftware, FALSE);

        if(lReg.GetSubKeyCount() == 0)
        {
            CString lName = lReg.ReadString("DisplayName", "");
            CString lDate = lReg.ReadString("InstallDate", "");


            if((lName.GetLength() == 0)&&(lDate.GetLength() == 0))
            {
                continue;
            }

            if(lName.GetLength() == 0)
            {
                res += lSoftwares[i].c_str();
            }
            else
            {
                res += lName;
            }
            
            if(lDate.GetLength() == 0)
            {
                
                res += DELIMITER" ";
            }
            else
            {
                
                res += DELIMITER;
                string ltmp = formatDate(lDate.GetBuffer(0));
                res += ltmp.c_str();
            }

            PResult.push_back(res.GetBuffer(0));
        }
    }
    
    return true;
}

/*
M/D/Y -> Y-M-D
20090101 -> 2009-01-01
*/
string RegisterOps::formatDate(string date)
{
    int y, m, d;
    int i = 0;
    int cnt = 0;
    bool allDigit = true;
    char buffer[32] = {0};

    while(i < date.length())
    {
        if(date[i] == '/')
        {
            cnt++;
        }
        if((date[i]<'0')||(date[i]>'9'))
        {
            allDigit = false;
        }
        i++;
    }
    if(allDigit)
    {
        //20090101 -> 2009-01-01
        sscanf(date.c_str(), "%4d%02d%02d", &y, &m, &d);
        sprintf(buffer, "%d-%d-%d", y, m, d);

        return buffer;
    }
    
    if(cnt != 2)
    {
        return date;
    }
    
    
    sscanf(date.c_str(), "%d/%d/%d", &m, &d, &y);

    sprintf(buffer, "%d-%d-%d", y, m, d);

    return buffer;
}



